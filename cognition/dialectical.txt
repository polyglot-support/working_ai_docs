# Dialectical Set Theory for Selfâ€‘Referential Multiâ€‘Party Systems (DZF)

**Status:** draft v0.1 â€¢ **Audience:** expert â€¢ **Style:** terse, operational

---

## 0. Executive summary

We generalize sets from static predicates (Boolean âˆˆ) to **dialectical predicates** with **inclusory** (growth) and **exclusory** (inhibition) dynamics. Membership is evaluated by **fixed points** of an evolution operator. The theory is a conservative extension over classical math on the **stable fragment** and adds native tools for recursion, feedback, defaults, and selfâ€‘reference.

---

## 1. Core primitives

### 1.1 Truth domain (bilattice)

Use Dunn/Belnap four values with two orders:

* Values: **T** (in), **F** (out), **B** (both), **N** (neither).
* **Truth order**: F â‰¤â‚œ N, F â‰¤â‚œ B, N â‰¤â‚œ T, B â‰¤â‚œ T.
* **Knowledge order**: N â‰¤â‚– F, N â‰¤â‚– T, F â‰¤â‚– B, T â‰¤â‚– B.
* Negation swaps Tâ†”F, fixes N, B; conjunction/disjunction are pointwise (pick either order as primary; default to â‰¤â‚– for fixedâ€‘point monotonicity).

### 1.2 Dialectical set

A **dialectical set** S over universe U is a predicate Ï•: U â†’ {T,F,B,N} obtained as a **(co)least fixed point** of an operator F on predicates.

* **Inclusory part** Sâº, **exclusory part** Sâ» are operators S â†¦ C(S) (inflation/closure) and S â†¦ I(S) (deflation/interior) with possible Galois connection I âŠ£ C.
* **Dynamics:** Sâ‚€ given; S\_{t+1} = ğ”‰(S\_t) where ğ”‰ can reference C and I and external signals.
* **Stable value:** S â‰” Î¼/Î½â€‘fixpoint of ğ”‰ in (Pred(U), â‰¤â‚–).  Equality is **stable extensionality**: S=T iff âˆ€x. S(x)=T â‡” T(x)=T **and** S(x)=F â‡” T(x)=F at the chosen fixpoint.

### 1.3 Conservative extension

**Stable sets** are those with no B/N values; restricted to them, DZF proves exactly the ZFC theorems stated in the classical language.

---

## 2. Axioms (DZF)

1. **Universe & pairing/union/infinity/replacement** as in ZF, but over dialectical predicates.
2. **Stable extensionality.** If two predicates agree at the fixpoint values for all x, the sets are equal.
3. **Restricted comprehension (fixedâ€‘point).** For any monotone ğ”‰: Pred(U)â†’Pred(U) (monotone in â‰¤â‚–), the sets Î¼ğ”‰ and Î½ğ”‰ exist; comprehension allowed only for such Î¼, Î½.
4. **Î¼/Î½ induction & coinduction.** Park/Tarski rules; alternationâ€‘depth governs proof strength.
5. **Paraconsistent negation.** From B do not infer arbitrary Ï† (no explosion). Classical reasoning is admissible on stable sets.
6. **Galois pair (optional axiom).** Postulate **I âŠ£ C** on Pred(U) (approximate interior/closure), idempotent and inflationary/deflationary respectively.

---

## 3. Semantics & models

* **Complete bilattices** of predicates (Uâ†’4) under â‰¤â‚–.
* **Topological model:** C=closure, I=interior; dynamics via alternation (Câˆ˜I)^Ï‰ fixed points.
* **(Co)algebra/dialgebra:** inclusory = algebraic constructors; exclusory = coalgebraic observers; dialectical objects are dialgebras with endofunctor G.
* **Chu/\*â€‘autonomous/linear** models: capture resource duality (antiâ€‘set intuition) natively.

---

## 4. Worked microâ€‘examples

### 4.1 Russellâ€‘style selfâ€‘reference (nonâ€‘explosive)

Define ğ”‰(S)(x) â‰” Â¬ S(xâˆˆx) (read: membership negates selfâ€‘membership). Iterating from N everywhere yields a fixed point with **B** on the diagonal (x with xâˆˆx) and N/T/F elsewhere depending on ground facts. No contradiction explosion; R is a wellâ€‘typed object with stable partial information.

### 4.2 Default negation / stable models

Let facts P; rules: a(x) â† p(x) âˆ§ Â¬b(x). Encode b as exclusory I; compute Î¼â€‘fixed points. This reproduces stableâ€‘model semantics without metaâ€‘encodings.

### 4.3 Creation/annihilation toy process

For counts over U, define Sâº via birth operator Î²; Sâ» via death operator Î´; predicate is B if both fire, N if neither, else T/F. Longâ€‘run stable membership = equilibrium of Î²,Î´.

---

## 5. Multiâ€‘party systems (core useâ€‘case)

### 5.1 System skeleton

* Agents Aâ‚â€¦Aâ‚™ emit **proposals** P\_iâº(S) and **vetos** P\_iâ»(S) as predicate transformers.
* **Merge:** ğ”‰(S) = Agg( {P\_iâº(S)} , {P\_iâ»(S)} ).  Agg must be â‰¤â‚–â€‘monotone (e.g., pointwise join for support and meet for opposition, or a residuated aggregator respecting I âŠ£ C).
* **Evaluation:** iterate S\_{t+1}=ğ”‰(S\_t) to Î¼/Î½; stabilization defines system outcome.

### 5.2 Concurrency & asynchrony

* Model delivery as monotone timeâ€‘stamps; fairness as Ï‰â€‘coverage. Use **upâ€‘to** techniques to reason modularly.
* **Confluence:** if Agg is Scottâ€‘continuous and updates commute up to adjunction, limit is unique (Churchâ€“Rosserâ€‘like lemma).

### 5.3 Conflict policies (T/F/B/N)

* **B** (both): conflict recognized; downstream rules may require quorum to resolve Bâ†’T or Bâ†’F.
* **N** (unknown): safe default; liveness rules push Nâ†’T/F once evidence accumulates.

### 5.4 Safety/liveness templates

* **Safety:** invariants are **Î½** properties; prove via coinduction.
* **Liveness:** progress is **Î¼**; use ranking on alternation depth.

---

## 6. Algebraic layer

* Lattices: move to **residuated/bilattice** operations; filters/ideals split into +/âˆ’ closures.  Fixed points generate **Jordan pairs** of closures.
* Homomorphisms must commute with Î¼/Î½ and (optionally) with I,C.

---

## 7. Analysis & measure

* Characteristic functions Ï‡\_S: Uâ†’4. Measures become **pairs** (Î¼âº, Î¼â») with valuation into â„\_{
  â‰¥0}; interpret net mass Î¼=Î¼âºâˆ’Î¼â». Integration respects bilattice order and monotone convergence in â‰¤â‚–.

---

## 8. Topology & dynamics

* A dialectical space is (U, I, C) with I âŠ£ C, idempotent. Stable opens = fixpoints of I; stable closeds = fixpoints of C.  Dynamics via (Iâˆ˜C)â€‘ or (Câˆ˜I)â€‘iterations; study limit cycles and ranks.

---

## 9. Logic & type theory

### 9.1 Curryâ€“Howard

* Judgments carry **positive** and **negative** evidence.  Types admit Î¼/Î½ (isoâ€‘recursive or equiâ€‘recursive).
* Refinements allow B/N inhabitants.

### 9.2 Rules (sketch)

* **Î¼â€‘intro:** from F(S) âŠ‘ S infer Î¼F âŠ‘ S.  **Î¼â€‘elim:** dual.  Likewise for Î½ with âŠ’.
* **Paraconsistent negation:** Î“ âŠ¢ A and Î“ âŠ¢ Â¬A does **not** entail Î“ âŠ¢ B.

---

## 10. Computation & complexity

* Membership evaluation = **fixpoint iteration**; cost tied to lattice height and alternation depth.
* With finite U and monotone ğ”‰, Î¼F reached in â‰¤ |U|Â·h steps (h: value stratification).  Alternation aligns with Î¼â€‘calculus modelâ€‘checking bounds.

---

## 11. Engineering patterns (readyâ€‘toâ€‘use)

### 11.1 Dialectical CRDT

* State includes Sâº, Sâ» components.  Merge is join on each; read semantics interprets T/F/B/N.  Strong eventual consistency via monotone propagation.

### 11.2 Allow/Deny policy engine

* Rules split into allowâº, denyâ»; conflicts surface as **B** (auditable).  Safety/liveness proofs via Î¼/Î½.

### 11.3 Multiâ€‘party consensus (dialectical Paxos)

* Accepts/rejects are +/âˆ’; quorum resolves Bâ†’T.  Partitions yield B/N transiently without violating safety.

### 11.4 Negotiation / games with defaults

* Bestâ€‘response operators provide ğ”‰; equilibria = Î½â€‘fixed points; commitments/constraints modeled as exclusory moves.

---

## 12. Minimal calculus (concrete)

### 12.1 Syntax

```
Terms   t ::= x | âŸ¨t,tâŸ© | â€¦
Vals    v âˆˆ {T, F, B, N}
Pred    p ::= a(t) | Â¬p | p âˆ§ p | p âˆ¨ p | Î¼X.F(X) | Î½X.F(X)
Op      F ::= Î»X. Î¦[X]           (Î¦ monotone in â‰¤â‚–)
Set     S ::= { x | Î¼X.F(X)(x) = T }
```

### 12.2 Inference (Î¼â€‘/Î½â€‘rules, schematic)

```
F(S) âŠ‘ S  â‡’  Î¼F âŠ‘ S            S âŠ‘ F(S)  â‡’  S âŠ‘ Î½F
S âŠ‘ T and T âŠ‘ S â‡’ S = T        (stable extensionality)
```

### 12.3 Evaluation algorithm (finite U)

```
function fixpoint_mu(F, bot):
    S := bot             # all N
    repeat:
        S' := F(S)
    until S' == S
    return S
```

---

## 13. Endâ€‘toâ€‘end example: selfâ€‘referential multiâ€‘party policy

* **U**: requests r.
* Agents A, B, C propose allow/deny via Pâº\_i, Pâ»\_i.
* **Agg:** pointwise join for supports, meet for vetos, with I âŠ£ C normalizing conflicts.
* **Spec:** safety = â€œnever grant when global veto holdsâ€ (Î½â€‘invariant), liveness = â€œevery pending N eventually resolvesâ€ (Î¼ with fairness).  Prove by (co)induction over ğ”‰.

---

## 14. Interop with classical math

* Theorems about stable sets carry over unchanged.
* When a classical proof uses complement or excluded middle, replace with I/C and Î¼/Î½ arguments.

---

## 15. Roadmap

1. Formalize DZF in a proof assistant (Agda/Coq/Lean via a bilattice library).
2. Library: Î¼/Î½ kits, adjunction APIs, dialectical CRDTs.
3. Benchmarks: modelâ€‘checking style kernels for large U; alternationâ€‘depth optimizations.
4. Case studies: access control, moderation pipelines, multiâ€‘stakeholder scheduling.

---

## 16. Open questions

* Best categorical completeness theorem for DZF with I âŠ£ C and Î¼/Î½.
* Canonical normal forms for Agg under concurrency.
* Complexity tight bounds for common policy fragments.

---

## 17. Glossary

* **Inclusory/Exclusory:** growth/inhibition operators (C/I).
* **Stable set:** all points T or F only.
* **B/N:** both/neither (conflict/unknown).
* **â‰¤â‚–:** knowledge order; monotone for ğ”‰.
* **Î¼/Î½:** least/greatest fixed point.
* **Stable extensionality:** equality by stabilized membership.

---

## 18. References (informal, for future citations)

* Dunn/Belnap bilattices; Î¼â€‘calculus; Tarski fixed points; coalgebra; Chu spaces; \*â€‘autonomous categories; abstract interpretation.

## 19. GÃ¶delâ€“Tarski in DZF (informational shape)

**Thesis.** Diagonal/self-referential knots remain, but evaluate to **B** (glut) or **N** (gap) at fixed points instead of detonating consistency. Classical theorems persist on the **stable fragment** (T/F only).

### 19.1 Fixed-point truth inside arithmetic

We add a unary predicate Tr\* to the arithmetic language and define it as a fixed point over the bilattice of valuations.

* Let Val: Sent â†’ {T, F, B, N}. Define an operator Eval(âˆ’, X): Sent â†’ {T, F, B, N} by structural clauses:

  * Atomic arithmetic facts: classical T/F.
  * Connectives/quantifiers: lifted pointwise in the bilattice (negation swaps Tâ†”F, fixes B and N; âˆ§, âˆ¨ are the bilattice ops; âˆ€ = inf, âˆƒ = sup over â‰¤â‚–).
  * Truth: Eval(Tr\*(âŒœÏ†âŒ), X) = X(âŒœÏ†âŒ).
* Gap policy (grounded truth): Tr\* â‰” Î¼X. Eval(âˆ’, X) (least fixed point in â‰¤â‚–).
* Glut policy (paraconsistent truth): Tr\* â‰” Î½X. Eval(âˆ’, X) (greatest fixed point in â‰¤â‚–).
* Designated values: cautious = {T}; bold = {T, B}.

Diagonal lemma gives G\_T â‰¡ Â¬Prov\_T(âŒœG\_TâŒ) inside T.

### 19.2 GÃ¶del sentence classification (at the fixed point)

Let v = Val(Prov\_T(âŒœG\_TâŒ)) at the chosen fixed point. Then

| v | Val(G\_T) | Reading                                                                                                         |
| - | --------- | --------------------------------------------------------------------------------------------------------------- |
| T | F         | â€œT proves G\_Tâ€ â‡’ G\_T is false (classically impossible for sound T; in paraconsistent T, yields a diagnostic). |
| F | T         | â€œUnprovableâ€ â‡’ G\_T true (classical case on stable fragment).                                                   |
| N | N         | Gap: provability undetermined â‡’ GÃ¶del lands N (Kripke-style grounded truth).                                    |
| B | B         | Glut: both provable and refutable in T â‡’ GÃ¶del lands B (paraconsistent reflection).                             |

Thus incompleteness persists as nonâ€‘T/F stabilization (N or B) unless the meta-facts of provability force F/T.

### 19.3 Liar trace (micro-iteration)

Let L â‰¡ Â¬Tr\*(âŒœLâŒ). Under the gap policy, start with X0 â‰¡ N on all sentences:

```
X0(âŒœLâŒ) = N
Eval(L, X0) = Â¬N = N
X1(âŒœLâŒ) = N  (fixed point reached)
```

Under the glut policy, Î½ selects the largest compatible valuation; depending on designated values and reflection, Val(L) = B can be sustained without explosion.

### 19.4 Second incompleteness: nonâ€‘triviality replaces consistency

* Classical: T âŠ¬ Con(T) (no proof of contradiction in T).
* Dialectical: contradictions do not explode; the salient global property is **NonTriv**:
  NonTriv(T) := Â¬âˆ€Ï† Prov\_T(âŒœÏ†âŒ).   (not everything is provable)

**Claim (shape of 2nd incompleteness).** For arithmetically adequate T satisfying adapted Hilbertâ€“Bernaysâ€“LÃ¶b conditions for the designated set D (cautious: D={T}; bold: D={T,B}):

* T does not prove NonTriv(T) outright.
* T can prove fragmented nonâ€‘triviality (e.g., for bounded Î¼/Î½ strata, or for the stable fragment), and relative nonâ€‘triviality (NonTriv(T) â‡’ NonTriv(T+Î±)).

Proof sketch. Diagonalize H â‰¡ (Prov\_T(âŒœHâŒ) â†’ âŠ¥\_D) where âŠ¥\_D is a sentence that would force designatedness to collapse if everything were provable. LÃ¶bâ€‘style reasoning shows that a proof of global NonTriv(T) would yield a designated H, contradicting the intended reading unless you drop the derivability conditions. (Full formalization left to appendix.)

### 19.5 Operational semantics

* Internal truth services. Implement Tr\* as a Î¼/Î½ evaluator; expose B/N to users as conflict/gap dashboards.
* Diagnostics. GÃ¶delâ€‘type sentences mark where your spec fails to stabilize (N) or overâ€‘constrains (B).
* Safety vs. liveness knobs. Choose Î½ for safetyâ€‘leaning obligations (coinductive) and Î¼ for liveness (inductive); this selects the fixed point used by Tr\* and by Prov\_T abstractions.

### 19.6 Quick reference (engineerâ€™s view)

* GÃ¶del/Tarski persist on the stable slice; elsewhere, they become typed phenomena (B/N) with measurable extent.
* â€œUndecidableâ€ â†’ computably classifiable: report where and why stabilization fails.
* Replace â€œprove consistencyâ€ with â€œprove nonâ€‘triviality of the fragment that mattersâ€.

## 20. Non-binary dialectical logic (graded and many-valued DZF)

**Goal.** Generalize FOUR = {T, F, B, N} to a value domain V with degrees of support/opposition while preserving fixedâ€‘point semantics, paraconsistency, and the stable classical fragment.

### 20.1 Truth domains V (choices)

* **Graded Belnap (pairs):** V = \[0,1]Ã—\[0,1] with values v=(s,o) = (degree of support, degree of opposition).

  * Knowledge order â‰¤â‚–: (sâ‚,oâ‚) â‰¤â‚– (sâ‚‚,oâ‚‚) iff sâ‚â‰¤sâ‚‚ and oâ‚â‰¤oâ‚‚.
  * Truth order â‰¤â‚œ: (sâ‚,oâ‚) â‰¤â‚œ (sâ‚‚,oâ‚‚) iff sâ‚â‰¤sâ‚‚ and oâ‚‚â‰¤oâ‚ (support up, opposition down).
  * Negation: Â¬(s,o) = (o,s). Conjunction/disjunction in â‰¤â‚– via componentwise min/max (or generic tâ€‘norm/tâ€‘conorm).
  * Designated sets: cautious D\_c = {(s,o) | o=0 and sâ‰¥Ï„}; bold D\_b = {(s,o) | sâ‰¥Ï„}.
  * FOUR embeds as (1,0)=T, (0,1)=F, (1,1)=B, (0,0)=N.
* **kâ€‘level ordinals:** V = {0,â€¦,k}Ã—{0,â€¦,k} with same ops (finite, gives exact termination bounds).
* **Residuated/MV/BL algebras:** choose a tâ€‘norm âŠ— and residuum â‡’ (GÃ¶del/Åukasiewicz/Product); build a De Morgan bilattice from two copies (truth vs knowledge) if needed.

### 20.2 Predicates and fixed points

* Pred(U,V) with pointwise â‰¤â‚– is a complete lattice when V is complete; Tarski yields Î¼F and Î½F for any â‰¤â‚–â€‘monotone F: Predâ†’Pred.
* Quantifiers: (âˆ€x Ï†) = infâ‚–\_x Ï†, (âˆƒx Ï†) = supâ‚–\_x Ï† (inf/sup in the knowledge order).
* Classical stable fragment = those x where vâˆˆ{(1,0),(0,1)} (or exact kâ€‘level analogues).

### 20.3 Inclusory/exclusory as adjoints

* Generalize I âŠ£ C to Vâ€‘valued predicates: I and C are endomaps on Pred(U,V) that are â‰¤â‚–â€‘monotone and satisfy I(S) â‰¤â‚– T iff S â‰¤â‚– C(T).
* In residuated settings, take C(S)=S âŠ— Îºâº and I(S)=S â‡’ Îºâ» for thresholds Îºâº, Îºâ» or use morphological erosions/dilations on s and o components.

### 20.4 Connectives (typical graded Belnap instance)

* Conj/Disj (knowledge aggregation): (s,o) âˆ§ (sâ€²,oâ€²) = (min(s,sâ€²), max(o,oâ€²)); (s,o) âˆ¨ (sâ€²,oâ€²) = (max(s,sâ€²), min(o,oâ€²)).
* Implication (residuated): a â‡’ b chosen to satisfy adjunction: a âŠ— c â‰¤â‚– b iff c â‰¤â‚– (a â‡’ b). For pairs, use componentwise variants or define on truth order and lift.

### 20.5 Multiâ€‘party aggregation (graded)

* Each agent i proposes allow a\_i(x)âˆˆ\[0,1] and deny d\_i(x)âˆˆ\[0,1].
* Aggregate support/opposition: s(x)=TCONORM\_i a\_i(x), o(x)=TCONORM\_i d\_i(x) (e.g., capped sum or probabilistic sum). Optionally weight by w\_i and normalize.
* Readâ€‘out policy: return T if oâ‰¤Îµ and sâ‰¥Ï„; F if sâ‰¤Îµ and oâ‰¥Ï„; B if sâ‰¥Ï„ and oâ‰¥Ï„; N otherwise. Thresholds (Ï„,Îµ) tune strictness.

### 20.6 Algorithms

* **Finite U, kâ€‘levels:** Î¼â€‘iteration stabilizes in â‰¤ |U|Â·k steps per component.
* **\[0,1]^2 continuous:** require F to be Scottâ€‘continuous or contractive (e.g., 1â€‘Lipschitz with coefficient <1) to ensure unique fixpoints; else use widening/narrowing (abstract interpretation) and iterate to a safe overâ€‘approximation, then narrow.
* **Symbolic:** represent predicates by constraints over s,o; compute images via convex or polyhedral ops when F is affine.

### 20.7 Paradox intensities

* Clash magnitude at x: c(x)=min(s(x),o(x)). Gap magnitude: g(x)=1âˆ’max(s(x),o(x)).
* Global metrics: C=Î£\_x c(x), G=Î£\_x g(x); track alternation depth during iteration. These quantify â€œhow paradoxicalâ€ rather than just that it is.

### 20.8 Interop and conservativity

* Embedding of classical math is unchanged: restrict to states where o=0 or s=0 and operations that preserve corners. All classical theorems over the stable slice carry over.
* Choices of tâ€‘norm family change algebraic laws (e.g., idempotence with GÃ¶del, divisibility with Åukasiewicz). Pick per application, prove fragment conservativity as needed.

### 20.9 Implementation sketch (engineerâ€™s interface)

```
interface TruthDomainV:
  # values
  type V
  bot_k() -> V             # knowledge-bottom (0,0)
  top_k() -> V              # knowledge-top (1,1)
  neg(v: V) -> V
  meet_k(v,w: V) -> V       # âˆ§ in â‰¤â‚–
  join_k(v,w: V) -> V       # âˆ¨ in â‰¤â‚–
  designated(v: V) -> bool  # pick D_c or D_b

fixpoint_mu(F, bot):
  S := bot
  repeat:
    S' := F(S)
  until S' == S
  return S
```

### 20.10 Miniâ€‘example (graded policy engine)

* U: requests. Agents output a\_i,d\_i. Aggregator computes s,o. Policy: allow if oâ‰¤0.1 and sâ‰¥0.8; deny if sâ‰¤0.1 and oâ‰¥0.8; else B or N. Fairness rules nudge N toward resolution over time (e.g., increase s for sustained approvals or increase o for repeated vetos).

**Outcome.** DZF scales to manyâ€‘valued settings by replacing FOUR with a complete value domain V, keeping Î¼/Î½ fixedâ€‘point semantics and adjoint inclusory/exclusory structure. Paradoxes become graded phenomena with measurable intensity, while the classical fragment remains intact.

## 21. Necessity & Impossibility Program (antiâ€‘sets as required machinery)

**Aim.** Formalize when antiâ€‘sets/dialectical truth values are **required**, not merely convenient, for objective formation in multiâ€‘agent systems.

### 21.1 Formal setup (aggregators over evidence)

Let U be propositions/events; agents i=1..n supply **evidence valuations** e\_i: Uâ†’V.

* **Classical baseline:** Vâ‚‚={T,F} with Boolean ops.
* **Dialectical:** Vâ‚„={T,F,B,N} or graded VâŠ†\[0,1]Â².
  An **aggregator** Agg: V^nâ†’V is lifted pointwise to U. We require structural properties:
* **(Cons)** Conservativity: if âˆ€i e\_i(x)=v, then Agg(e\_1..e\_n)(x)=v.
* **(Anon)** Anonymity: invariant under agent permutations.
* **(Mono)** Evidenceâ€‘monotonicity: increasing any agentâ€™s support cannot decrease the outcome in the knowledge order â‰¤â‚–.
* **(NC)** Nonâ€‘coercion of disagreement: when the profile contains both positive and negative support on x, the output must **expose** disagreement (not collapse to a unanimous Boolean value).
* **(Idem)** Idempotence: duplicating an agent does not change the outcome.
  Optional temporal properties for streams: **(Live)** fairness â‡’ eventual decision when evidence stabilizes; **(Safe)** no false positives under permanent global veto.

### 21.2 Core impossibility (twoâ€‘valued collapse)

**Theorem 21.1 (No honest totalizer on Vâ‚‚).** There is no aggregator Agg: Vâ‚‚^nâ†’Vâ‚‚ satisfying (Cons),(Anon),(Mono),(NC),(Idem).

*Sketch.* Consider single issue x. By (Cons) and (Anon), Agg is determined by the number k of T votes. (Mono) forces Agg to be thresholdâ€‘based: there exists Î¸ with Agg(k)=T iff kâ‰¥Î¸. Symmetry between T/F via relabeling yields a dual threshold Î¸â€² for F. (NC) requires that for 1â‰¤kâ‰¤nâˆ’1, Agg(k)â‰ T and Agg(k)â‰ F, contradiction. Hence any honest exposure of disagreement demands **extra values** beyond {T,F} (e.g., B or N).

**Corollary 21.2.** Any system that simultaneously wants (Cons),(Anon),(Mono),(Idem) and **honest disagreement signaling** must adopt a nonâ€‘binary value set (dialectical or graded).

### 21.3 Asynchrony/consensus necessity

**Theorem 21.3 (FLPâ€‘shaped semantic necessity).** In an asynchronous messageâ€‘passing model with even one crash failure, no deterministic protocol can guarantee (Agreement, Termination, Validity) **and** (Honesty): the decided value equals the actual Boolean state of the world on every run. If outputs are restricted to {T,F}, any protocol that guarantees Termination must sometimes violate Honesty. Allowing N (â€œundecidedâ€) or B (â€œconflictâ€) restores feasibility (Agreement/Termination/Honesty on designated outcomes), with N/B exposing the FLP bivalence rather than hiding it.

*Sketch.* Map FLPâ€™s bivalent configurations to semantic N/B. A totalizing twoâ€‘valued decider would choose T or F in a bivalent configuration, contradicting FLPâ€™s valency argument unless it can output a **nonâ€‘decided** value. Dialectical outputs let the protocol terminate while remaining honest about information state.

### 21.4 Undefinability of internal classical truth â‡’ need for Î¼/Î½

**Theorem 21.4 (Tarski barrier for Vâ‚‚, feasibility for Vâ‚„).** No arithmetical theory T interprets a **bivalent** internal truth predicate satisfying Tarski biconditionals for all sentences of T (classical result). In DZF with Tr\* defined as Î¼/Î½ fixed point over Vâ‚„, an internal truth service satisfying **dialectical** biconditionals is definable and nonâ€‘explosive. Thus, any architecture requiring **total, selfâ€‘referential, inâ€‘system truth evaluation** must depart from Vâ‚‚.

### 21.5 Deontic safety under contraryâ€‘toâ€‘duty (CTD)

**Theorem 21.5 (Explosion vs. safety).** In standard deontic logic with classical negation, adding a consistent base plus a CTD pair O(p) and O(Â¬p|p) yields trivialization of obligations or counterintuitive collapse under natural closure rules. In a paraconsistent/dialectical setting, obligations evaluate to B at conflict points; safety theorems (no arbitrary O(q)) hold. Therefore, any system that must remain **nonâ€‘trivial** under CTD is forced to adopt paraconsistent/dialectical semantics.

### 21.6 Expressivity separation

**Theorem 21.6 (Spec expressivity gap).** There exists a class of multiâ€‘agent livenessâ€‘withâ€‘veto specs S expressible in a **bilattice Î¼â€‘calculus** over Vâ‚„ but not definable in any firstâ€‘order or modal logic over Vâ‚‚ without fixed points that preserves (Cons),(Mono) and exposes disagreement. (Reduction from standard Î¼â€‘calculus expressivity separations + requirement (NC).)

### 21.7 Positive possibility in DZF

Constructive duals to 21.1â€“21.6:

* **Existence 21.A.** Aggregators on Vâ‚„ (e.g., join/meet on support/opposition with thresholds) satisfy (Cons),(Anon),(Mono),(NC),(Idem).
* **Protocol 21.B.** Asynchronous consensus with outputs in {T,F,N} achieves Agreement/Validity/Termination; N is used exactly on bivalent runs.
* **Truth 21.C.** Tr\* via Î¼ or Î½ internalizes grounded/paraconsistent truth without explosion.

### 21.8 Empirical program

Benchmarks comparing Vâ‚‚ vs Vâ‚„ architectures on ethical/multiâ€‘stakeholder datasets:

* Rate of **false confidence** (forced T/F vs honest B/N).
* Decision latency vs. quality under adversarial disagreement.
* Human trust/calibration when presented with B/N dashboards.

### 21.9 What to formalize next

1. Tighten 21.1 to minimal axiom sets. 2) State a precise asynchrony model for 21.3 and define â€œHonestyâ€. 3) Pin down the logic class in 21.6 (e.g., ALTL vs Î¼â€‘calculus) and give a concrete separation.

**Bottom line.** The above theorems frame antiâ€‘sets not as â€œnice to haveâ€ but as mathematically **necessary** for objective formation under natural desiderata. Next: pick one theorem (21.1 or 21.3) and write the full formal proof.

## 22. Interaction Logic â€” Minimality, Representation, Universality

**Claim.** The four Belnap values are forced as the coarsest honest summary of two interacting binary logics; for k agents / richer base logics the interaction space lifts to signatures of observed values, with Belnap as a canonical quotient.

### 22.1 Setup (profiles â†’ summaries)

* Agents A1â€¦Ak output Î±\_i âˆˆ {T, F, âŠ¥} (âŠ¥ = noâ€‘commit/absent; drop âŠ¥ for the synchronous case).
* A profile on issue x is the multiset P(x) = {Î±\_1,â€¦,Î±\_k}.
* Counts: s(x)=#T, o(x)=#F, u(x)=#âŠ¥.  Write cnt(P)=(s,o,u).

Aggregator desiderata (pointwise on x):

* (Cons) Conservativity: unanimous profiles map to that value.
* (Anon) Anonymity: invariant under permuting agents.
* (Neut) Neutrality Tâ†”F: swapping T and F in inputs swaps them in outputs.
* (Idem) Idempotence: duplicating an agent doesnâ€™t change output.
* (Mono\_k) Knowledgeâ€‘monotonicity: increasing s or o or u (as information accumulates) cannot invent unanimity; decisions refine information, not erase it.
* (Hon) Honesty: mixed s>0 and o>0 must be labeled conflict; hollow s=o=0 must be labeled gap.

By (Anon, Idem) any aggregator factors through counts: âˆƒf with Agg(P)=f(cnt(P)).

### 22.2 Minimality theorem (binary, 2 interactors)

**Theorem 22.1.** Any f satisfying (Cons, Neut, Mono\_k, Hon) takes values in a fourâ€‘element lattice isomorphic to Belnapâ€™s FOUR: {T, F, B, N} with Nâ‰¤\_kT, Nâ‰¤\_kF, Tâ‰¤\_kB, Fâ‰¤\_kB.

Sketch. The only invariant classes of profiles under (Anon, Neut, Idem) are: (i) s>0,o=0 (supportâ€‘only); (ii) s=0,o>0 (oppâ€‘only); (iii) s>0,o>0 (conflict); (iv) s=o=0 (gap). (Hon) forbids merging (iii)/(iv) with (i)/(ii). (Cons) forbids splitting (i) or (ii). Thus the codomain must distinguish exactly these four; any further quotient violates a desideratum. The induced order is the knowledge order.

### 22.3 Representation theorem (k interactors, triâ€‘valued inputs)

Let V3={T, F, âŠ¥}. Profiles factor to signatures Ïƒ(P) âŠ† V3: the set of distinct values present.

**Theorem 22.2.** Any aggregator satisfying (Cons, Anon, Neut, Idem) and signatureâ€‘invariance corresponds to a monotone map from the Boolean lattice P(V3){âˆ…} onto a target lattice. The coarsest honest map merges {T}â†¦T, {F}â†¦F, {âŠ¥}â†¦N, {T,F}â†¦B, and treats {T,âŠ¥},{F,âŠ¥},{T,F,âŠ¥} via a policy; Belnap is recovered when {T,âŠ¥} and {F,âŠ¥} are not collapsed to T/F by (Mono\_k, Hon).

### 22.4 General nâ€‘ary bases

For base values V0 of size n, the signature lattice is P(V0){âˆ…}. Honest, anonymous, neutral aggregators factor through signatures. Belnap is the binary caseâ€™s minimal honest quotient; graded Belnap \[0,1]^2 is the free continuous homomorphic image via normalization (s,o)â†¦(s/k, o/k).

### 22.5 Universal property

FOUR is the coarsest lattice (initial in the category of honest quotients) that separates: supportâ€‘only, opposeâ€‘only, conflict, gap. Any honest aggregator factors uniquely through the canonical map Pâ†¦ {T,F}â€‘signature â†’ FOUR.

### 22.6 Engineering corollaries

* CRDTs, consensus, sensor fusion: expose B/N as firstâ€‘class; thresholds are interpretations of graded (s,o).
* Proof obligations: show Agg factors through counts/signatures; choose quotient = Belnap (coarse) or graded (fine). Contracts state how {T,âŠ¥} and {F,âŠ¥} collapse.

### 22.7 Naming

â€œInteraction Logic (IL)â€ = DZFâ€™s operational core; DZF supplies Î¼/Î½ fixed points and I âŠ£ C structure on top of ILâ€™s valueâ€‘level universals.

## 23. Minimal probabilistic interaction (2-party, 3-outcome)

Setup. Two agents output in {T, F}. Readout collapses to three outcomes: T=(T,T), F=(F,F), B=(T,F) or (F,T) (no gap here).

### 23.1 Symmetry constraints

Agent exchangeability, label symmetry Tâ†”F, and no extra structure. Then the general symmetric law is
Pr\[T]=Pr\[F]=a,  Pr\[B]=1-2a,  0 â‰¤ a â‰¤ 1/2.   (â˜…)

### 23.2 Canonical choices for x = (Pr\[T], Pr\[F], Pr\[B])

* Independence @ 50â€“50 â‡’ x=(1/4, 1/4, 1/2).
* Max-entropy given (â˜…) â‡’ x=(1/3, 1/3, 1/3).
* Exchangeable de Finetti (Î¸\~Beta(Î±,Î±)) â‡’
  Pr\[T]=Pr\[F]=(Î±+1)/(4Î±+2),  Pr\[B]=Î±/(2Î±+1).  Î±=1 â‡’ (1/3,1/3,1/3); Î±â†’âˆ â‡’ (1/4,1/4,1/2).

### 23.3 With gaps (âŠ¥)

Allow abstention and add N. Symmetric Dirichlet(Î±,Î±,Î±) over {agreeâ€‘T, agreeâ€‘F, conflict} (and optionally N) yields a closed form; Î±=1 gives Pr\[T]=Pr\[F]=Pr\[N]=1/6, Pr\[B]=1/2.

TL;DR: â€œSymmetrical invariantâ€ x is (1/3,1/3,1/3) under symmetry-only ignorance; with i.i.d. 50â€“50 agents it is (1/4,1/4,1/2). Pick per assumption set.